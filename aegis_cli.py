import click
import json

# Assuming backend modules are in the same directory or PYTHONPATH
import did_system
import project_management
import contribution_workflow
import ipfs_storage # Though not directly called by CLI, its init might print messages
import platform_token # New import for platform token interactions
import p2p_messaging # New import for P2P messaging
import asyncio # For running async P2P functions
import decimal # For precise amount conversions
import decimal # For precise amount conversions

# Helper to pretty print JSON
def print_json(data):
    if data is not None:
        click.echo(json.dumps(data, indent=2, sort_keys=True))
    else:
        click.echo("No data to display.")

@click.group()
def cli():
    """Aegis Forge Command Line Interface."""
    # Check IPFS connection early if possible, or let individual commands fail.
    # For now, let ipfs_storage.py handle its initial connection message.
    if ipfs_storage.client is None: # Assuming ipfs_storage module sets its client to None on failure
        click.secho("Warning: IPFS daemon does not seem to be running. Some commands will fail.", fg="yellow")
    
    # Check Platform Token contract initialization
    if platform_token.w3 is None or platform_token.aegis_token_contract is None:
        click.secho("Warning: Platform Token (AegisToken) contract not initialized. `token` commands may fail.", fg="yellow")
        click.secho("Ensure Ganache is running and AegisToken contract is deployed (AegisToken.address.txt exists).", fg="yellow")
    
    # Check DID Registry contract initialization
    if did_system.w3 is None or did_system.did_registry_contract is None:
        click.secho("Warning: DIDRegistry contract not initialized. `did` commands and some project/contribution commands may fail.", fg="yellow")
        click.secho("Ensure Ganache is running and DIDRegistry contract is deployed (DIDRegistry.address.txt exists).", fg="yellow")
    pass

# --- DID Commands ---
@cli.group('did')
def did_group():
    """Manage DIDs on the blockchain via DIDRegistry contract."""
    pass

@did_group.command('register')
@click.argument('unique_identifier_string')
@click.option('--public-key', required=True, help="Public key string for the DID.")
@click.option('--doc-cid', required=True, help="IPFS CID of the DID document.")
@click.option('--owner-address', required=True, help="Ethereum address of the DID owner (pays gas).")
@click.option('--owner-pk', required=True, help="Private key of the owner address (for signing). WARNING: For local testing with Ganache keys ONLY.")
def did_register(unique_identifier_string, public_key, doc_cid, owner_address, owner_pk):
    """Registers a new DID on the blockchain. The unique_identifier_string is hashed to create the bytes32 DID."""
    click.secho("WARNING: Private key input is for local development with Ganache test accounts only. Do not use real private keys here.", fg="yellow")
    if not did_system.w3 or not did_system.did_registry_contract:
        click.secho("Web3 or DIDRegistry contract not initialized. Check Ganache connection and contract deployment.", fg="red")
        return
    try:
        did_bytes32 = did_system.generate_did_identifier(unique_identifier_string)
        click.echo(f"Generated bytes32 DID: 0x{did_bytes32.hex()}")
        
        success = did_system.register_did(did_bytes32, public_key, doc_cid, owner_address, owner_pk)
        if success:
            click.secho(f"DID '0x{did_bytes32.hex()}' (from '{unique_identifier_string}') registered successfully!", fg="green")
        else:
            click.secho(f"Failed to register DID for '{unique_identifier_string}'. See backend logs.", fg="red")
    except Exception as e:
        click.secho(f"Error during DID registration: {e}", fg="red")

@did_group.command('show')
@click.argument('unique_identifier_string')
def did_show(unique_identifier_string):
    """Shows details for a specific DID by its unique identifier string."""
    if not did_system.w3 or not did_system.did_registry_contract:
        click.secho("Web3 or DIDRegistry contract not initialized. Check Ganache connection and contract deployment.", fg="red")
        return
    try:
        did_bytes32 = did_system.generate_did_identifier(unique_identifier_string)
        click.echo(f"Querying for bytes32 DID: 0x{did_bytes32.hex()} (from '{unique_identifier_string}')")
        
        did_info = did_system.get_did_info(did_bytes32)
        if did_info:
            print_json(did_info)
        else:
            click.secho(f"DID for '{unique_identifier_string}' (0x{did_bytes32.hex()}) not found or error retrieving.", fg="yellow")
    except Exception as e:
        click.secho(f"Error showing DID details: {e}", fg="red")

@did_group.command('list')
def did_list():
    """(Deprecated for blockchain) Lists DIDs."""
    click.secho("Listing all DIDs directly from the blockchain is not supported in this version.", fg="yellow")
    click.echo("Please query DIDs individually using 'did show <unique_identifier_string>' or use event listeners for comprehensive tracking (not implemented in CLI).")
    click.echo("For testing, you can check the 'dids.json' file if a backup/off-chain store were being maintained (not part of current contract interaction).")

@did_group.command('update-pubkey')
@click.argument('unique_identifier_string')
@click.option('--new-public-key', required=True, help="The new public key string.")
@click.option('--owner-address', required=True, help="Ethereum address of the DID owner.")
@click.option('--owner-pk', required=True, help="Private key of the owner. WARNING: For local testing ONLY.")
def did_update_pubkey(unique_identifier_string, new_public_key, owner_address, owner_pk):
    """Updates the public key for a DID."""
    click.secho("WARNING: Private key input is for local development with Ganache test accounts only. Do not use real private keys here.", fg="yellow")
    if not did_system.w3 or not did_system.did_registry_contract:
        click.secho("Web3 or DIDRegistry contract not initialized. Check Ganache connection and contract deployment.", fg="red")
        return
    try:
        did_bytes32 = did_system.generate_did_identifier(unique_identifier_string)
        click.echo(f"Attempting to update public key for DID: 0x{did_bytes32.hex()} (from '{unique_identifier_string}')")
        success = did_system.update_public_key(did_bytes32, new_public_key, owner_address, owner_pk)
        if success:
            click.secho(f"Public key for DID '0x{did_bytes32.hex()}' updated successfully!", fg="green")
        else:
            click.secho(f"Failed to update public key for DID '0x{did_bytes32.hex()}'. See backend logs.", fg="red")
    except Exception as e:
        click.secho(f"Error updating public key: {e}", fg="red")

@did_group.command('update-doc-cid')
@click.argument('unique_identifier_string')
@click.option('--new-doc-cid', required=True, help="The new IPFS CID for the DID document.")
@click.option('--owner-address', required=True, help="Ethereum address of the DID owner.")
@click.option('--owner-pk', required=True, help="Private key of the owner. WARNING: For local testing ONLY.")
def did_update_doc_cid(unique_identifier_string, new_doc_cid, owner_address, owner_pk):
    """Updates the document CID for a DID."""
    click.secho("WARNING: Private key input is for local development with Ganache test accounts only. Do not use real private keys here.", fg="yellow")
    if not did_system.w3 or not did_system.did_registry_contract:
        click.secho("Web3 or DIDRegistry contract not initialized. Check Ganache connection and contract deployment.", fg="red")
        return
    try:
        did_bytes32 = did_system.generate_did_identifier(unique_identifier_string)
        click.echo(f"Attempting to update document CID for DID: 0x{did_bytes32.hex()} (from '{unique_identifier_string}')")
        success = did_system.update_document_cid(did_bytes32, new_doc_cid, owner_address, owner_pk)
        if success:
            click.secho(f"Document CID for DID '0x{did_bytes32.hex()}' updated successfully!", fg="green")
        else:
            click.secho(f"Failed to update document CID for DID '0x{did_bytes32.hex()}'. See backend logs.", fg="red")
    except Exception as e:
        click.secho(f"Error updating document CID: {e}", fg="red")

@did_group.command('check-registered')
@click.argument('unique_identifier_string')
def did_check_registered(unique_identifier_string):
    """Checks if a DID (derived from the string) is registered on the blockchain."""
    if not did_system.w3 or not did_system.did_registry_contract:
        click.secho("Web3 or DIDRegistry contract not initialized. Check Ganache connection and contract deployment.", fg="red")
        return
    try:
        did_bytes32 = did_system.generate_did_identifier(unique_identifier_string)
        click.echo(f"Checking registration status for DID: 0x{did_bytes32.hex()} (from '{unique_identifier_string}')")
        is_registered = did_system.is_did_registered(did_bytes32)
        click.echo(f"Is registered: {is_registered}")
    except Exception as e:
        click.secho(f"Error checking DID registration: {e}", fg="red")


# --- Project Commands ---
@cli.group('project')
def project_group():
    """Manage Projects."""
    pass

@project_group.command('create')
@click.argument('project_name')
@click.option('--owner-did', required=True, help="The unique identifier string for the project owner's DID (will be hashed).")
@click.option('--owner-address', required=True, help="The Ethereum address of the project owner (for contract interaction if needed, though project creation is off-chain).")
# The owner-pk is not directly used by project_management.create_project but good to keep pattern if other project interactions need it.
# For now, project creation itself in project_management.py doesn't require signing a blockchain tx for project metadata.
# However, owner_did (the string) needs to be valid on the DIDRegistry if we cross-check.
@click.option('--supply', type=int, default=1000000, show_default=True, help="Initial token supply for the project.")
@click.option('--owner-pk', required=True, help="Private key of the owner/deployer for deploying the project token contract. WARNING: For local testing ONLY.")
def project_create(project_name, owner_did, owner_address, supply, owner_pk):
    """Creates a new project and deploys its on-chain token. Owner DID must be registered and match owner_address."""
    click.secho("WARNING: Private key input ('--owner-pk') is for local development with Ganache test accounts only. Do not use real private keys here.", fg="yellow", bold=True)

    if not did_system.w3 or not did_system.did_registry_contract:
        click.secho("Web3 or DIDRegistry contract not initialized. Check Ganache and contract deployment.", fg="red")
        return
    
    owner_did_bytes32 = did_system.generate_did_identifier(owner_did)
    if not did_system.is_did_registered(owner_did_bytes32):
        click.secho(f"Error: Owner DID (from string '{owner_did}') '0x{owner_did_bytes32.hex()}' is not registered on the blockchain.", fg="red")
        return
    
    did_info = did_system.get_did_info(owner_did_bytes32)
    if not did_info:
        click.secho(f"Error: Could not retrieve info for owner DID '{owner_did}'.", fg="red")
        return
    if did_info.get('owner', '').lower() != owner_address.lower():
        click.secho(f"Error: The provided owner_address '{owner_address}' does not match the registered Ethereum owner ('{did_info.get('owner')}') of DID '{owner_did}'.", fg="red")
        return

    try:
        project_data = project_management.create_project(
            project_name=project_name,
            owner_did=owner_did, # The DID string
            token_supply=supply,
            owner_private_key=owner_pk # PK for the owner_eth_address linked to owner_did
        )
        if project_data:
            click.secho(f"Project '{project_name}' created successfully!", fg="green")
            click.echo(f"Project Token Contract Address: {project_data.get('project_token_contract_address')}")
            print_json(project_data)
        else:
            click.secho(f"Failed to create project '{project_name}'. See backend logs for details (check Ganache, deploy_project_token.py script output).", fg="red")
    except Exception as e:
        click.secho(f"Error creating project: {e}", fg="red")

@project_group.command('list')
def project_list():
    """Lists all projects."""
    try:
        projects = project_management.list_projects()
        if projects:
            print_json(projects)
        else:
            click.echo("No projects found.")
    except Exception as e:
        click.secho(f"Error listing projects: {e}", fg="red")

@project_group.command('show')
@click.argument('project_id')
def project_show(project_id):
    """Shows details for a specific project by its project_id (sanitized name)."""
    try:
        project_data = project_management.get_project(project_id)
        if project_data:
            print_json(project_data)
        else:
            click.secho(f"Project '{project_id}' not found.", fg="yellow")
    except Exception as e:
        click.secho(f"Error showing project '{project_id}': {e}", fg="red")

@project_group.command('balance')
@click.argument('project_id')
@click.argument('did_unique_string')
def project_balance(project_id, did_unique_string):
    """Shows on-chain token balance of a DID (specified by its unique string) for a specific project."""
    if not did_system.w3: # Web3 must be initialized (usually by did_system loading)
        click.secho("Web3 is not initialized. Check Ganache connection and contract deployments.", fg="red")
        return

    w3 = did_system.w3 # Use the initialized Web3 instance from did_system

    try:
        project_data = project_management.get_project(project_id)
        if not project_data:
            click.secho(f"Project '{project_id}' not found.", fg="yellow")
            return

        token_contract_address_str = project_data.get("project_token_contract_address")
        if not token_contract_address_str:
            click.secho(f"Project '{project_id}' does not have an on-chain token contract address listed.", fg="red")
            return

        token_contract_address = w3.to_checksum_address(token_contract_address_str)

        # Resolve DID string to Ethereum address
        did_bytes32 = did_system.generate_did_identifier(did_unique_string)
        if not did_system.is_did_registered(did_bytes32):
            click.secho(f"Error: DID for '{did_unique_string}' (0x{did_bytes32.hex()}) is not registered on the blockchain.", fg="red")
            return
        
        did_info = did_system.get_did_info(did_bytes32)
        if not did_info or "owner" not in did_info:
            click.secho(f"Error: Could not retrieve Ethereum address for DID '{did_unique_string}'.", fg="red")
            return
        holder_eth_address_str = did_info["owner"]
        holder_eth_address = w3.to_checksum_address(holder_eth_address_str)

        # Load ProjectToken ABI
        abi_file_path = "ProjectToken.abi.json"
        if not os.path.exists(abi_file_path):
            click.secho(f"Error: ProjectToken ABI file '{abi_file_path}' not found. Compile contracts first.", fg="red")
            return
        with open(abi_file_path, 'r') as f:
            token_abi = json.load(f)

        # Create contract instance
        token_contract = w3.eth.contract(address=token_contract_address, abi=token_abi)

        # Fetch balance, decimals, and symbol
        balance_smallest_units = token_contract.functions.balanceOf(holder_eth_address).call()
        token_decimals = token_contract.functions.decimals().call()
        token_symbol = token_contract.functions.symbol().call()

        balance_readable = decimal.Decimal(balance_smallest_units) / (decimal.Decimal(10) ** token_decimals)

        click.echo(f"Token balance for DID '{did_unique_string}' (Address: {holder_eth_address_str}) in project '{project_id}':")
        click.echo(f"  {balance_readable.quantize(decimal.Decimal('0.000001'))} {token_symbol}") # Adjust precision as needed
        click.echo(f"  (Smallest units: {balance_smallest_units})")

    except Exception as e:
        click.secho(f"Error getting on-chain balance for project '{project_id}', DID '{did_unique_string}': {e}", fg="red")
        import traceback
        traceback.print_exc()


# --- Contribution Commands ---
@cli.group('contribution')
def contribution_group():
    """Manage Contributions to Projects."""
    pass

@contribution_group.command('submit')
@click.argument('project_id')
@click.option('--contributor-did', 'contributor_did_string', required=True, help="The unique identifier string of the contributor's DID.")
@click.option('--title', required=True, help="Title of the contribution.")
@click.option('--description', required=True, help="Description of the contribution.")
@click.option('--file', 'content_file_path', required=True, type=click.Path(exists=True, dir_okay=False, readable=True), help="Path to the file containing the contribution content.")
def contribution_submit(project_id, contributor_did_string, title, description, content_file_path):
    """Submits a new contribution proposal to a project. Contributor DID must be registered."""
    if not did_system.w3 or not did_system.did_registry_contract:
        click.secho("Web3 or DIDRegistry contract not initialized. Cannot verify contributor DID.", fg="red")
        return

    # Validate contributor_did_string
    contributor_did_bytes32 = did_system.generate_did_identifier(contributor_did_string)
    if not did_system.is_did_registered(contributor_did_bytes32):
        click.secho(f"Error: Contributor DID (from string '{contributor_did_string}') '0x{contributor_did_bytes32.hex()}' is not registered on the blockchain.", fg="red")
        return
    
    # Ensure the project exists (contribution_workflow.submit_contribution also checks this, but early exit is good)
    if not project_management.get_project(project_id):
        click.secho(f"Error: Project '{project_id}' not found.", fg="red")
        return

    try:
        # contribution_workflow.submit_contribution expects the string version of the DID
        proposal_id = contribution_workflow.submit_contribution(
            project_id, contributor_did_string, title, description, content_file_path
        )
        if proposal_id:
            click.secho(f"Contribution '{title}' submitted successfully!", fg="green")
            click.echo(f"Proposal ID: {proposal_id}")
        else:
            click.secho(f"Failed to submit contribution for project '{project_id}'. See backend logs.", fg="red")
    except Exception as e:
        click.secho(f"Error submitting contribution: {e}", fg="red")

@contribution_group.command('list')
@click.option('--project-id', help="Optional project ID to filter contributions.")
def contribution_list(project_id):
    """Lists all contributions, or those for a specific project."""
    try:
        if project_id:
            # Validate project_id exists if provided
            if not project_management.get_project(project_id):
                click.secho(f"Error: Project '{project_id}' not found.", fg="red")
                return
            contributions = contribution_workflow.list_contributions_for_project(project_id)
            if not contributions:
                 click.echo(f"No contributions found for project '{project_id}'.")
                 return
        else:
            contributions = contribution_workflow.list_all_contributions()
            if not contributions:
                click.echo("No contributions found in the system.")
                return
        
        print_json(contributions)
    except Exception as e:
        click.secho(f"Error listing contributions: {e}", fg="red")

@contribution_group.command('show')
@click.argument('proposal_id')
def contribution_show(proposal_id):
    """Shows details for a specific contribution proposal."""
    try:
        proposal_data = contribution_workflow.get_contribution(proposal_id)
        if proposal_data:
            print_json(proposal_data)
        else:
            click.secho(f"Contribution proposal '{proposal_id}' not found.", fg="yellow")
    except Exception as e:
        click.secho(f"Error showing contribution proposal '{proposal_id}': {e}", fg="red")

@contribution_group.command('review')
@click.argument('proposal_id')
@click.option('--reviewer-did', 'reviewer_did_string', required=True, help="The unique identifier string of the reviewer's DID (must be project owner).")
@click.option('--reviewer-pk', required=True, help="Private key of the reviewer (project owner) for signing token reward transactions. WARNING: For local testing ONLY.")
@click.option('--status', required=True, type=click.Choice(['approved', 'rejected'], case_sensitive=False), help="New status for the proposal.")
@click.option('--reward', type=int, default=0, show_default=True, help="Token reward amount if approved.")
def contribution_review(proposal_id, reviewer_did_string, reviewer_pk, status, reward):
    """Reviews a contribution proposal. Reviewer DID must be registered and be the project owner."""
    click.secho("WARNING: Private key input ('--reviewer-pk') is for local development with Ganache test accounts only. Do not use real private keys here.", fg="yellow", bold=True)

    if not did_system.w3 or not did_system.did_registry_contract:
        click.secho("Web3 or DIDRegistry contract not initialized. Cannot verify reviewer DID.", fg="red")
        return

    reviewer_did_bytes32 = did_system.generate_did_identifier(reviewer_did_string)
    if not did_system.is_did_registered(reviewer_did_bytes32):
        click.secho(f"Error: Reviewer DID (from string '{reviewer_did_string}') '0x{reviewer_did_bytes32.hex()}' is not registered.", fg="red")
        return
    
    # contribution_workflow.review_contribution will further validate if reviewer_did_string is project owner
    try:
        success = contribution_workflow.review_contribution(
            proposal_id=proposal_id,
            reviewer_did=reviewer_did_string,
            reviewer_private_key=reviewer_pk,
            new_status=status,
            reward_amount=reward
        )
        if success:
            click.secho(f"Contribution proposal '{proposal_id}' reviewed successfully. New status: {status}.", fg="green")
        else:
            click.secho(f"Failed to review contribution proposal '{proposal_id}'. See backend logs (check Ganache, token transfer details).", fg="red")
    except Exception as e:
        click.secho(f"Error reviewing contribution: {e}", fg="red")

# --- Platform Token Commands ---
@cli.group('token')
def token_group():
    """Manage the $AEGIS Platform Token."""
    if platform_token.w3 is None or platform_token.aegis_token_contract is None:
        click.secho("Critical: Platform Token system not initialized. Cannot execute token commands.", fg="red")
        click.secho("Please ensure Ganache is running and the AegisToken contract has been deployed, and its address/ABI are correctly configured.", fg="red")
        # Optionally, exit here if token commands are absolutely critical and cannot proceed
        # import sys
        # sys.exit(1)
    pass

@token_group.command('info')
def token_info():
    """Displays information about the $AEGIS platform token."""
    if not platform_token.aegis_token_contract:
        click.secho("Platform token contract not available. Check initialization.", fg="red")
        return
    try:
        name = platform_token.get_token_name()
        symbol = platform_token.get_token_symbol()
        decimals = platform_token.get_token_decimals()
        total_supply_smallest_units = platform_token.get_total_supply()

        click.echo("--- $AEGIS Platform Token Information ---")
        click.echo(f"Name: {name if name else 'N/A'}")
        click.echo(f"Symbol: {symbol if symbol else 'N/A'}")
        click.echo(f"Decimals: {decimals if decimals is not None else 'N/A'}")

        if total_supply_smallest_units is not None and decimals is not None:
            total_supply_readable = decimal.Decimal(total_supply_smallest_units) / (decimal.Decimal(10) ** decimals)
            click.echo(f"Total Supply: {total_supply_readable.quantize(decimal.Decimal('1.'))} {symbol if symbol else 'tokens'}")
            click.echo(f"Total Supply (smallest units): {total_supply_smallest_units}")
        else:
            click.echo(f"Total Supply: Error retrieving")

    except Exception as e:
        click.secho(f"Error retrieving token info: {e}", fg="red")

@token_group.command('balance')
@click.argument('eth_address')
def token_balance(eth_address):
    """Displays the $AEGIS token balance for a given Ethereum address."""
    if not platform_token.aegis_token_contract:
        click.secho("Platform token contract not available. Check initialization.", fg="red")
        return
    try:
        balance_smallest_units = platform_token.get_aegis_balance(eth_address)
        decimals = platform_token.get_token_decimals()
        symbol = platform_token.get_token_symbol()

        if balance_smallest_units is not None and decimals is not None:
            balance_readable = decimal.Decimal(balance_smallest_units) / (decimal.Decimal(10) ** decimals)
            click.echo(f"Balance for {eth_address}: {balance_readable.quantize(decimal.Decimal('1.'))} {symbol if symbol else 'tokens'}")
            click.echo(f"Balance (smallest units): {balance_smallest_units}")
        else:
            click.secho(f"Could not retrieve balance or token decimals for {eth_address}.", fg="red")

    except Exception as e:
        click.secho(f"Error retrieving token balance for {eth_address}: {e}", fg="red")

@token_group.command('transfer')
@click.option('--from-address', required=True, help="Sender's Ethereum address.")
@click.option('--from-pk', required=True, help="Sender's private key. WARNING: For local testing ONLY.")
@click.option('--to-address', required=True, help="Recipient's Ethereum address.")
@click.option('--amount', 'amount_str', required=True, help="Amount of $AEGIS to transfer (e.g., '100.5').")
def token_transfer(from_address, from_pk, to_address, amount_str):
    """Transfers $AEGIS tokens from one address to another."""
    click.secho("WARNING: Private key input is for local development with Ganache test accounts only. Do not use real private keys here.", fg="yellow")
    if not platform_token.aegis_token_contract or not platform_token.w3:
        click.secho("Platform token contract or Web3 not available. Check initialization.", fg="red")
        return
    
    try:
        decimals = platform_token.get_token_decimals()
        if decimals is None:
            click.secho("Could not retrieve token decimals. Cannot process transfer.", fg="red")
            return

        try:
            amount_decimal = decimal.Decimal(amount_str)
        except decimal.InvalidOperation:
            click.secho(f"Error: Invalid amount '{amount_str}'. Please provide a valid number.", fg="red")
            return
        
        if amount_decimal <= 0:
            click.secho("Error: Transfer amount must be positive.", fg="red")
            return

        amount_in_smallest_units = int(amount_decimal * (decimal.Decimal(10) ** decimals))
        click.echo(f"Attempting to transfer {amount_decimal} $AEGIS ({amount_in_smallest_units} smallest units)...")

        success = platform_token.transfer_aegis(
            sender_address=from_address,
            sender_private_key=from_pk,
            recipient_address=to_address,
            amount_in_smallest_units=amount_in_smallest_units
        )

        if success:
            click.secho("Token transfer successful!", fg="green")
        else:
            click.secho("Token transfer failed. See backend logs for details.", fg="red")

    except Exception as e:
        click.secho(f"An error occurred during token transfer: {e}", fg="red")

# --- P2P Messaging Commands ---
@cli.group('p2p')
def p2p_group():
    """Manage P2P encrypted messaging."""
    # Check if did_system is initialized, as p2p_messaging relies on it for public keys
    if did_system.w3 is None or did_system.did_registry_contract is None:
        click.secho("Warning: DIDRegistry contract not initialized. P2P commands may fail if DID lookups are needed.", fg="yellow")
        click.secho("Ensure Ganache is running and DIDRegistry contract is deployed.", fg="yellow")
    pass

@p2p_group.command('start-server')
@click.option('--did', 'did_identifier_string', required=True, help="The unique string identifier for this server's DID.")
@click.option('--pk', 'hex_private_key', required=True, help="Hex private key for this server's DID (for message decryption). WARNING: For local testing ONLY.")
@click.option('--host', default="0.0.0.0", show_default=True, help="Host address to bind the server to.")
@click.option('--port', default=9999, type=int, show_default=True, help="Port to bind the server to.")
def p2p_start_server(did_identifier_string, hex_private_key, host, port):
    """Starts a P2P server to listen for encrypted messages."""
    click.secho("WARNING: Providing a private key directly on the command line is insecure and should ONLY be done with test accounts in a local development environment.", fg="red", bold=True)
    click.secho(f"Starting P2P server for DID '{did_identifier_string}' on {host}:{port}...", fg="cyan")
    click.secho("The server will run indefinitely. Press Ctrl+C to stop.", fg="cyan")
    
    # Validate DID is registered and has a public key (implicitly checked by send_message, but good for server context)
    # However, the server only needs its own private key for decryption, not necessarily its on-chain registration for *receiving*.
    # The sender needs the recipient's (this server's) on-chain public key.
    
    # Basic validation of private key format (length of hex string)
    if not (hex_private_key.startswith("0x") and len(hex_private_key) == 66):
        click.secho("Error: Private key must be a 64-character hex string prefixed with '0x'.", fg="red")
        return

    try:
        asyncio.run(p2p_messaging.start_server(host, port, did_identifier_string, hex_private_key))
    except KeyboardInterrupt:
        click.echo("\nP2P server shutting down...")
    except Exception as e:
        click.secho(f"Error starting P2P server: {e}", fg="red")
        click.secho("Ensure the port is not already in use and necessary modules are correctly initialized.", fg="red")

@p2p_group.command('send-message')
@click.option('--recipient-did', 'recipient_did_string', required=True, help="The unique string identifier for the recipient's DID.")
@click.option('--recipient-host', required=True, help="Hostname/IP of the recipient's P2P server.")
@click.option('--recipient-port', required=True, type=int, help="Port of the recipient's P2P server.")
@click.option('--message', required=True, help="The text message to send.")
def p2p_send_message(recipient_did_string, recipient_host, recipient_port, message):
    """Sends an E2E encrypted message to a P2P server."""
    
    if not did_system.w3 or not did_system.did_registry_contract:
        click.secho("Error: DID system not initialized. Cannot retrieve recipient's public key.", fg="red")
        click.secho("Ensure Ganache is running and DIDRegistry contract is deployed and configured.", fg="red")
        return
        
    click.echo(f"Preparing to send message to DID '{recipient_did_string}' at {recipient_host}:{recipient_port}...")
    try:
        success = asyncio.run(p2p_messaging.send_message_p2p(
            target_host=recipient_host,
            target_port=recipient_port,
            recipient_did_identifier_string=recipient_did_string,
            message=message
        ))
        if success:
            click.secho("Message sent successfully (encrypted).", fg="green")
        else:
            click.secho("Failed to send message. See backend logs or server status.", fg="red")
    except Exception as e:
        click.secho(f"Error sending P2P message: {e}", fg="red")


if __name__ == '__main__':
    cli()
